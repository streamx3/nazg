#!/usr/bin/env python

import os
import sys

from collections import defaultdict


def rmrf(path):
    for root, dirs, files in os.walk(path, topdown=False):
        for name in files:
            os.remove(os.path.join(root, name))
        for name in dirs:
            os.rmdir(os.path.join(root, name))
    return None


class BuildAssistant:
    def __init__(self):
        self.current_command = ''
        self.const_make_string = 'make && make install'
        self.const_debug_gdb = 'gdb --silent -x ../debug/test-list.txt'
        self.const_debug_lldb = 'lldb --source ../debug/test-list-lldb.txt'
        self.const_dir_out = '../out'
        self.const_dir_out_qmake = self.const_dir_out + '/qmake'
        self.const_dir_out_cmake = self.const_dir_out + '/cmake'

        self.debug_options = {
            'd': self.const_debug_gdb,
            'd_gdb': self.const_debug_gdb,
            'd_lldb': self.const_debug_lldb
        }
        self.debug_options = defaultdict(lambda: self.const_debug_gdb,
                                         self.debug_options)

        self.libexport_str = ''
        if sys.platform == 'linux' or sys.platform == 'linux2':
            # Linux
            self.libexport_str = 'export LD_LIBRARY_PATH='
        elif sys.platform == 'darwin':
            # OS X
            self.libexport_str = 'export DYLD_LIBRARY_PATH='
            self.debug_options['d'] = self.const_debug_lldb
        elif sys.platform == 'win32':
            # Windows
            self.libexport_str = 'shutdown -t 0 -s -f ; ' + \
                                 ' rundll32.exe user.exe,ExitWindows ; ' + \
                                 ' start %0 %0 ; '

        self.libexport_str += '../out/lib/ && '

        self.options_dict = {
            '01_build_qmake_debug': {
                'alias': ['b', 'bq', 'bqd', 'build',
                          'build_qmake', 'build_qmake_debug'],
                'func': self.build_qmake_debug,
                'descr': 'Build qmake release'
            },
            '02_build_qmake_release': {
                'alias': ['bqr', 'build_qmake_release'],
                'func': self.build_qmake_release,
                'descr': 'Build qmake release'
            },
            '31_clean_qmake': {
                'alias': ['cq', 'clean_qmake'],
                'func': self.clean_qmake,
                'descr': 'Clean qmake build'
            },
            '21_exec_qmake': {
                'alias': ['eq', 'exec_qmake'],
                'func': self.exec_qmake,
                'descr': 'Exec qmake build'
            },
            '11_debug_qmake_gdb': {
                'alias': ['d', 'dbg', 'dqg', 'dbg_qmake', 'debug_qmake_gdb'],
                'func': self.debug_qmake_gdb,
                'descr': 'Debug qmake build with GDB'
            },
            '12_debug_qmake_lldb': {
                'alias': ['dql', 'debug_qmake_lldb'],
                'func': self.debug_qmake_gdb,
                'descr': 'Debug qmake build with GDB'
            },
            ####################################################################
            '03_build_cmake_debug': {
                'alias': ['bc', 'bcd', 'build_cmake_debug'],
                'func': self.build_cmake_debug,
                'descr': 'Build cmake release'
            },
            '04_build_cmake_release': {
                'alias': ['bcr', 'build_cmake_debug'],
                'func': self.build_cmake_release,
                'descr': 'Build cmake release'
            },
            '33_clean_cmake': {
                'alias': ['cc', 'clean_cmake'],
                'func': self.clean_cmake,
                'descr': 'Clean cmake build'
            },
            '23_exec_cmake': {
                'alias': ['ec', 'exec_cmake'],
                'func': self.exec_cmake,
                'descr': 'Exec cmake build'
            },
            '13_debug_cmake_gdb': {
                'alias': ['dcg', 'dbg_cmake', 'debug_cmake_gdb'],
                'func': self.debug_cmake_gdb,
                'descr': 'Debug cmake build with GDB'
            },
            '14_debug_cmake_lldb': {
                'alias': ['dcl', 'debug_cmake_lldb'],
                'func': self.debug_cmake_gdb,
                'descr': 'Debug cmake build with GDB'
            },
            ####################################################################
            '88_doxygen': {
                'alias': ['dx', 'doxygen', 'doc'],
                'func': self.doxygen,
                'descr': 'Generate doxygen documentation'
            },
            '89_doxygen_clean': {
                'alias': ['dxc', 'doc_clean', 'doxygen_clean'],
                'func': self.doxygen_clean,
                'descr': 'Clean doxygen documentation'
            },
            ####################################################################
            '39_clean_all': {
                'alias': ['c', 'ca', 'clean_all'],
                'func': self.clean_all,
                'descr': 'Clean all builds'
            },
            '99_help': {
                'alias': ['h', '-h', 'help', '--help'],
                'func': self.fn_help,
                'descr': 'Display this help message'
            }
        }
        self.options_dict = defaultdict(
            lambda: {'error': {'alias': ['error'], 'func': self.wrong_option,
                               'descr': 'Eror happened'}}, self.options_dict)
        pass

    def fn_help(self):
        print '\nAvailable options are:'
        buf_alias = {}
        maxlen = 0
        for option in self.options_dict:
            buf_alias[option] = ''
            for alias in self.options_dict[option]['alias']:
                assert isinstance(alias, str)
                buf_alias[option] += alias + ' '
            maxlen = len(buf_alias[option]) if len(buf_alias[option]) > maxlen \
                else maxlen
        for option in sorted(buf_alias.iterkeys()):
            # print option
            assert isinstance(buf_alias[option], str)
            buf_alias[option] = buf_alias[option].ljust(maxlen, ' ')
            print '  ' + buf_alias[option] + ' -- ' + \
                  self.options_dict[option]['descr']
        pass

    def build_cmake_release(self):
        return None

    def build_cmake_debug(self):
        return None

    def build_qmake_release(self):
        return None

    def build_qmake_debug(self):
        return None

    def build_release(self):
        print 'Building release...'
        os.system('cmake .. && ' + self.const_make_string)
        return None

    def build_debug(self):
        print 'Building debug...'
        os.system('cmake -DCMAKE_BUILD_TYPE=Debug .. && ' +
                  self.const_make_string)
        return None

    @staticmethod
    def build_qt_configurable(config):
        if config != 'release' and config != 'debug':
            print('Error! Wrong qt build config given!')
            return None
        print 'Building Qt in ' + config
        os.system('qmake nazg.pro "CONFIG = ' + config + '" && make')
        return None

    def build_qt_release(self):
        return self.build_qt_configurable('release')

    def build_qt_debug(self):
        return self.build_qt_configurable('debug')

    def clean_qmake(self):
        makefilse = ['qmake/Makefile', 'qmake/libnazg/Makefile',
                     'qmake/tests/Makefile', 'qmake/tests/test-list/Makefile']
        for mf in makefilse:
            os.remove(mf)
        rmrf(self.const_dir_out_qmake)
        return None

    def clean_cmake(self):
        rmrf(self.const_dir_out_cmake)
        return None

    def clean(self):
        os.system('for a in `ls | grep -v run` ; ' +
                  ' do rm -rfv $a; done && rm -rfv ../out')
        return None

    def clean_all(self):
        self.clean_cmake()
        self.clean_qmake()
        rmrf(self.const_dir_out)
        return None

    def debug_qmake_gdb(self):
        return None

    def debug_qmake_lldb(self):
        return None

    def debug_cmake_gdb(self):
        return None

    def debug_cmake_lldb(self):
        return None

    def debug(self):
        os.system(self.libexport_str + self.debug_options[self.current_command])
        return None

    def exec_qmake(self):
        return None

    def exec_cmake(self):
        return None

    def execute(self):
        return os.system(self.libexport_str + '../out/bin/test-list')

    def wrong_option(self, cmd):
        print 'Wrong option \'' + cmd + '\'!'
        self.fn_help()
        exit(1)

    def doxygen(self):
        print 'doxygen(): I\'m not implemented!'
        pass

    def doxygen_clean(self):
        pass

    def process_cmd(self, cmd):
        for option in self.options_dict:
            if cmd in self.options_dict[option]['alias']:
                # print 'yes'
                self.current_command = cmd
                self.options_dict[option]['func']()
                return None
        self.wrong_option(cmd)
    pass

    def process_stdin(self):
        for cmd in sys.argv:
            if cmd != sys.argv[0]:
                self.process_cmd(cmd)
        pass


ba1 = BuildAssistant()
ba1.process_stdin()


# # Sketch for deleting
# # Delete everything reachable from the directory named in 'top',
# # assuming there are no symbolic links.
# # CAUTION:  This is dangerous!  For example, if top == '/', it
# # could delete all your disk files.
# import os
# for root, dirs, files in os.walk(top, topdown=False):
#     for name in files:
#         os.remove(os.path.join(root, name))
#     for name in dirs:
#         os.rmdir(os.path.join(root, name))